var ce=Object.defineProperty;var de=(e,t,r)=>t in e?ce(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r;var c=(e,t,r)=>de(e,typeof t!="symbol"?t+"":t,r);import{t as u}from"./site-CaX0jgUv.js";const V=new TextEncoder,T=new TextDecoder;function fe(...e){const t=e.reduce((a,{length:i})=>a+i,0),r=new Uint8Array(t);let n=0;for(const a of e)r.set(a,n),n+=a.length;return r}function D(e){const t=new Uint8Array(e.length);for(let r=0;r<e.length;r++){const n=e.charCodeAt(r);if(n>127)throw new TypeError("non-ASCII string encountered in encode()");t[r]=n}return t}function ue(e){if(Uint8Array.fromBase64)return Uint8Array.fromBase64(e);const t=atob(e),r=new Uint8Array(t.length);for(let n=0;n<t.length;n++)r[n]=t.charCodeAt(n);return r}function C(e){if(Uint8Array.fromBase64)return Uint8Array.fromBase64(typeof e=="string"?e:T.decode(e),{alphabet:"base64url"});let t=e;t instanceof Uint8Array&&(t=T.decode(t)),t=t.replace(/-/g,"+").replace(/_/g,"/");try{return ue(t)}catch{throw new TypeError("The input to be decoded is not correctly encoded.")}}class E extends Error{constructor(r,n){var a;super(r,n);c(this,"code","ERR_JOSE_GENERIC");this.name=this.constructor.name,(a=Error.captureStackTrace)==null||a.call(Error,this,this.constructor)}}c(E,"code","ERR_JOSE_GENERIC");class p extends E{constructor(r,n,a="unspecified",i="unspecified"){super(r,{cause:{claim:a,reason:i,payload:n}});c(this,"code","ERR_JWT_CLAIM_VALIDATION_FAILED");c(this,"claim");c(this,"reason");c(this,"payload");this.claim=a,this.reason=i,this.payload=n}}c(p,"code","ERR_JWT_CLAIM_VALIDATION_FAILED");class x extends E{constructor(r,n,a="unspecified",i="unspecified"){super(r,{cause:{claim:a,reason:i,payload:n}});c(this,"code","ERR_JWT_EXPIRED");c(this,"claim");c(this,"reason");c(this,"payload");this.claim=a,this.reason=i,this.payload=n}}c(x,"code","ERR_JWT_EXPIRED");class Y extends E{constructor(){super(...arguments);c(this,"code","ERR_JOSE_ALG_NOT_ALLOWED")}}c(Y,"code","ERR_JOSE_ALG_NOT_ALLOWED");class S extends E{constructor(){super(...arguments);c(this,"code","ERR_JOSE_NOT_SUPPORTED")}}c(S,"code","ERR_JOSE_NOT_SUPPORTED");class f extends E{constructor(){super(...arguments);c(this,"code","ERR_JWS_INVALID")}}c(f,"code","ERR_JWS_INVALID");class U extends E{constructor(){super(...arguments);c(this,"code","ERR_JWT_INVALID")}}c(U,"code","ERR_JWT_INVALID");class Z extends E{constructor(r="signature verification failed",n){super(r,n);c(this,"code","ERR_JWS_SIGNATURE_VERIFICATION_FAILED")}}c(Z,"code","ERR_JWS_SIGNATURE_VERIFICATION_FAILED");const m=(e,t="algorithm.name")=>new TypeError(`CryptoKey does not support this operation, its ${t} must be ${e}`),A=(e,t)=>e.name===t;function O(e){return parseInt(e.name.slice(4),10)}function le(e){switch(e){case"ES256":return"P-256";case"ES384":return"P-384";case"ES512":return"P-521";default:throw new Error("unreachable")}}function pe(e,t){if(!e.usages.includes(t))throw new TypeError(`CryptoKey does not support this operation, its usages must include ${t}.`)}function he(e,t,r){switch(t){case"HS256":case"HS384":case"HS512":{if(!A(e.algorithm,"HMAC"))throw m("HMAC");const n=parseInt(t.slice(2),10);if(O(e.algorithm.hash)!==n)throw m(`SHA-${n}`,"algorithm.hash");break}case"RS256":case"RS384":case"RS512":{if(!A(e.algorithm,"RSASSA-PKCS1-v1_5"))throw m("RSASSA-PKCS1-v1_5");const n=parseInt(t.slice(2),10);if(O(e.algorithm.hash)!==n)throw m(`SHA-${n}`,"algorithm.hash");break}case"PS256":case"PS384":case"PS512":{if(!A(e.algorithm,"RSA-PSS"))throw m("RSA-PSS");const n=parseInt(t.slice(2),10);if(O(e.algorithm.hash)!==n)throw m(`SHA-${n}`,"algorithm.hash");break}case"Ed25519":case"EdDSA":{if(!A(e.algorithm,"Ed25519"))throw m("Ed25519");break}case"ML-DSA-44":case"ML-DSA-65":case"ML-DSA-87":{if(!A(e.algorithm,t))throw m(t);break}case"ES256":case"ES384":case"ES512":{if(!A(e.algorithm,"ECDSA"))throw m("ECDSA");const n=le(t);if(e.algorithm.namedCurve!==n)throw m(n,"algorithm.namedCurve");break}default:throw new TypeError("CryptoKey does not support this operation")}pe(e,r)}function Q(e,t,...r){var n;if(r=r.filter(Boolean),r.length>2){const a=r.pop();e+=`one of type ${r.join(", ")}, or ${a}.`}else r.length===2?e+=`one of type ${r[0]} or ${r[1]}.`:e+=`of type ${r[0]}.`;return t==null?e+=` Received ${t}`:typeof t=="function"&&t.name?e+=` Received function ${t.name}`:typeof t=="object"&&t!=null&&(n=t.constructor)!=null&&n.name&&(e+=` Received an instance of ${t.constructor.name}`),e}const ye=(e,...t)=>Q("Key must be ",e,...t),k=(e,t,...r)=>Q(`Key for the ${e} algorithm must be `,t,...r),j=e=>{if((e==null?void 0:e[Symbol.toStringTag])==="CryptoKey")return!0;try{return e instanceof CryptoKey}catch{return!1}},ee=e=>(e==null?void 0:e[Symbol.toStringTag])==="KeyObject",te=e=>j(e)||ee(e);function me(...e){const t=e.filter(Boolean);if(t.length===0||t.length===1)return!0;let r;for(const n of t){const a=Object.keys(n);if(!r||r.size===0){r=new Set(a);continue}for(const i of a){if(r.has(i))return!1;r.add(i)}}return!0}const Se=e=>typeof e=="object"&&e!==null;function P(e){if(!Se(e)||Object.prototype.toString.call(e)!=="[object Object]")return!1;if(Object.getPrototypeOf(e)===null)return!0;let t=e;for(;Object.getPrototypeOf(t)!==null;)t=Object.getPrototypeOf(t);return Object.getPrototypeOf(e)===t}function we(e,t){if(e.startsWith("RS")||e.startsWith("PS")){const{modulusLength:r}=t.algorithm;if(typeof r!="number"||r<2048)throw new TypeError(`${e} requires key modulusLength to be 2048 bits or larger`)}}function Ee(e){let t,r;switch(e.kty){case"AKP":{switch(e.alg){case"ML-DSA-44":case"ML-DSA-65":case"ML-DSA-87":t={name:e.alg},r=e.priv?["sign"]:["verify"];break;default:throw new S('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break}case"RSA":{switch(e.alg){case"PS256":case"PS384":case"PS512":t={name:"RSA-PSS",hash:`SHA-${e.alg.slice(-3)}`},r=e.d?["sign"]:["verify"];break;case"RS256":case"RS384":case"RS512":t={name:"RSASSA-PKCS1-v1_5",hash:`SHA-${e.alg.slice(-3)}`},r=e.d?["sign"]:["verify"];break;case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":t={name:"RSA-OAEP",hash:`SHA-${parseInt(e.alg.slice(-3),10)||1}`},r=e.d?["decrypt","unwrapKey"]:["encrypt","wrapKey"];break;default:throw new S('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break}case"EC":{switch(e.alg){case"ES256":t={name:"ECDSA",namedCurve:"P-256"},r=e.d?["sign"]:["verify"];break;case"ES384":t={name:"ECDSA",namedCurve:"P-384"},r=e.d?["sign"]:["verify"];break;case"ES512":t={name:"ECDSA",namedCurve:"P-521"},r=e.d?["sign"]:["verify"];break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":t={name:"ECDH",namedCurve:e.crv},r=e.d?["deriveBits"]:[];break;default:throw new S('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break}case"OKP":{switch(e.alg){case"Ed25519":case"EdDSA":t={name:"Ed25519"},r=e.d?["sign"]:["verify"];break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":t={name:e.crv},r=e.d?["deriveBits"]:[];break;default:throw new S('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break}default:throw new S('Invalid or unsupported JWK "kty" (Key Type) Parameter value')}return{algorithm:t,keyUsages:r}}async function J(e){if(!e.alg)throw new TypeError('"alg" argument is required when "jwk.alg" is not present');const{algorithm:t,keyUsages:r}=Ee(e),n={...e};return n.kty!=="AKP"&&delete n.alg,delete n.use,crypto.subtle.importKey("jwk",n,t,e.ext??!(e.d||e.priv),e.key_ops??r)}async function be(e,t,r){if(!P(e))throw new TypeError("JWK must be an object");let n;switch(t??(t=e.alg),n??(n=e.ext),e.kty){case"oct":if(typeof e.k!="string"||!e.k)throw new TypeError('missing "k" (Key Value) Parameter value');return C(e.k);case"RSA":if("oth"in e&&e.oth!==void 0)throw new S('RSA JWK "oth" (Other Primes Info) Parameter value is not supported');return J({...e,alg:t,ext:n});case"AKP":{if(typeof e.alg!="string"||!e.alg)throw new TypeError('missing "alg" (Algorithm) Parameter value');if(t!==void 0&&t!==e.alg)throw new TypeError("JWK alg and alg option value mismatch");return J({...e,ext:n})}case"EC":case"OKP":return J({...e,alg:t,ext:n});default:throw new S('Unsupported "kty" (Key Type) Parameter value')}}function ge(e,t,r,n,a){if(a.crit!==void 0&&(n==null?void 0:n.crit)===void 0)throw new e('"crit" (Critical) Header Parameter MUST be integrity protected');if(!n||n.crit===void 0)return new Set;if(!Array.isArray(n.crit)||n.crit.length===0||n.crit.some(o=>typeof o!="string"||o.length===0))throw new e('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');let i;r!==void 0?i=new Map([...Object.entries(r),...t.entries()]):i=t;for(const o of n.crit){if(!i.has(o))throw new S(`Extension Header Parameter "${o}" is not recognized`);if(a[o]===void 0)throw new e(`Extension Header Parameter "${o}" is missing`);if(i.get(o)&&n[o]===void 0)throw new e(`Extension Header Parameter "${o}" MUST be integrity protected`)}return new Set(n.crit)}function Ae(e,t){if(t!==void 0&&(!Array.isArray(t)||t.some(r=>typeof r!="string")))throw new TypeError(`"${e}" option must be an array of strings`);if(t)return new Set(t)}const N=e=>P(e)&&typeof e.kty=="string",ve=e=>e.kty!=="oct"&&(e.kty==="AKP"&&typeof e.priv=="string"||typeof e.d=="string"),Ke=e=>e.kty!=="oct"&&e.d===void 0&&e.priv===void 0,Ce=e=>e.kty==="oct"&&typeof e.k=="string";let K;const F=async(e,t,r,n=!1)=>{K||(K=new WeakMap);let a=K.get(e);if(a!=null&&a[r])return a[r];const i=await J({...t,alg:r});return n&&Object.freeze(e),a?a[r]=i:K.set(e,{[r]:i}),i},Te=(e,t)=>{var o;K||(K=new WeakMap);let r=K.get(e);if(r!=null&&r[t])return r[t];const n=e.type==="public",a=!!n;let i;if(e.asymmetricKeyType==="x25519"){switch(t){case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":break;default:throw new TypeError("given KeyObject instance cannot be used for this algorithm")}i=e.toCryptoKey(e.asymmetricKeyType,a,n?[]:["deriveBits"])}if(e.asymmetricKeyType==="ed25519"){if(t!=="EdDSA"&&t!=="Ed25519")throw new TypeError("given KeyObject instance cannot be used for this algorithm");i=e.toCryptoKey(e.asymmetricKeyType,a,[n?"verify":"sign"])}switch(e.asymmetricKeyType){case"ml-dsa-44":case"ml-dsa-65":case"ml-dsa-87":{if(t!==e.asymmetricKeyType.toUpperCase())throw new TypeError("given KeyObject instance cannot be used for this algorithm");i=e.toCryptoKey(e.asymmetricKeyType,a,[n?"verify":"sign"])}}if(e.asymmetricKeyType==="rsa"){let s;switch(t){case"RSA-OAEP":s="SHA-1";break;case"RS256":case"PS256":case"RSA-OAEP-256":s="SHA-256";break;case"RS384":case"PS384":case"RSA-OAEP-384":s="SHA-384";break;case"RS512":case"PS512":case"RSA-OAEP-512":s="SHA-512";break;default:throw new TypeError("given KeyObject instance cannot be used for this algorithm")}if(t.startsWith("RSA-OAEP"))return e.toCryptoKey({name:"RSA-OAEP",hash:s},a,n?["encrypt"]:["decrypt"]);i=e.toCryptoKey({name:t.startsWith("PS")?"RSA-PSS":"RSASSA-PKCS1-v1_5",hash:s},a,[n?"verify":"sign"])}if(e.asymmetricKeyType==="ec"){const d=new Map([["prime256v1","P-256"],["secp384r1","P-384"],["secp521r1","P-521"]]).get((o=e.asymmetricKeyDetails)==null?void 0:o.namedCurve);if(!d)throw new TypeError("given KeyObject instance cannot be used for this algorithm");t==="ES256"&&d==="P-256"&&(i=e.toCryptoKey({name:"ECDSA",namedCurve:d},a,[n?"verify":"sign"])),t==="ES384"&&d==="P-384"&&(i=e.toCryptoKey({name:"ECDSA",namedCurve:d},a,[n?"verify":"sign"])),t==="ES512"&&d==="P-521"&&(i=e.toCryptoKey({name:"ECDSA",namedCurve:d},a,[n?"verify":"sign"])),t.startsWith("ECDH-ES")&&(i=e.toCryptoKey({name:"ECDH",namedCurve:d},a,n?[]:["deriveBits"]))}if(!i)throw new TypeError("given KeyObject instance cannot be used for this algorithm");return r?r[t]=i:K.set(e,{[t]:i}),i};async function Pe(e,t){if(e instanceof Uint8Array||j(e))return e;if(ee(e)){if(e.type==="secret")return e.export();if("toCryptoKey"in e&&typeof e.toCryptoKey=="function")try{return Te(e,t)}catch(n){if(n instanceof TypeError)throw n}let r=e.export({format:"jwk"});return F(e,r,t)}if(N(e))return e.k?C(e.k):F(e,e,t,!0);throw new Error("unreachable")}const v=e=>e==null?void 0:e[Symbol.toStringTag],H=(e,t,r)=>{var n,a;if(t.use!==void 0){let i;switch(r){case"sign":case"verify":i="sig";break;case"encrypt":case"decrypt":i="enc";break}if(t.use!==i)throw new TypeError(`Invalid key for this operation, its "use" must be "${i}" when present`)}if(t.alg!==void 0&&t.alg!==e)throw new TypeError(`Invalid key for this operation, its "alg" must be "${e}" when present`);if(Array.isArray(t.key_ops)){let i;switch(!0){case r==="verify":case e==="dir":case e.includes("CBC-HS"):i=r;break;case e.startsWith("PBES2"):i="deriveBits";break;case/^A\d{3}(?:GCM)?(?:KW)?$/.test(e):!e.includes("GCM")&&e.endsWith("KW")?i="unwrapKey":i=r;break;case r==="encrypt":i="wrapKey";break;case r==="decrypt":i=e.startsWith("RSA")?"unwrapKey":"deriveBits";break}if(i&&((a=(n=t.key_ops)==null?void 0:n.includes)==null?void 0:a.call(n,i))===!1)throw new TypeError(`Invalid key for this operation, its "key_ops" must include "${i}" when present`)}return!0},Re=(e,t,r)=>{if(!(t instanceof Uint8Array)){if(N(t)){if(Ce(t)&&H(e,t,r))return;throw new TypeError('JSON Web Key for symmetric algorithms must have JWK "kty" (Key Type) equal to "oct" and the JWK "k" (Key Value) present')}if(!te(t))throw new TypeError(k(e,t,"CryptoKey","KeyObject","JSON Web Key","Uint8Array"));if(t.type!=="secret")throw new TypeError(`${v(t)} instances for symmetric algorithms must be of type "secret"`)}},Ie=(e,t,r)=>{if(N(t))switch(r){case"decrypt":case"sign":if(ve(t)&&H(e,t,r))return;throw new TypeError("JSON Web Key for this operation must be a private JWK");case"encrypt":case"verify":if(Ke(t)&&H(e,t,r))return;throw new TypeError("JSON Web Key for this operation must be a public JWK")}if(!te(t))throw new TypeError(k(e,t,"CryptoKey","KeyObject","JSON Web Key"));if(t.type==="secret")throw new TypeError(`${v(t)} instances for asymmetric algorithms must not be of type "secret"`);if(t.type==="public")switch(r){case"sign":throw new TypeError(`${v(t)} instances for asymmetric algorithm signing must be of type "private"`);case"decrypt":throw new TypeError(`${v(t)} instances for asymmetric algorithm decryption must be of type "private"`)}if(t.type==="private")switch(r){case"verify":throw new TypeError(`${v(t)} instances for asymmetric algorithm verifying must be of type "public"`);case"encrypt":throw new TypeError(`${v(t)} instances for asymmetric algorithm encryption must be of type "public"`)}};function Je(e,t,r){switch(e.substring(0,2)){case"A1":case"A2":case"di":case"HS":case"PB":Re(e,t,r);break;default:Ie(e,t,r)}}function We(e,t){const r=`SHA-${e.slice(-3)}`;switch(e){case"HS256":case"HS384":case"HS512":return{hash:r,name:"HMAC"};case"PS256":case"PS384":case"PS512":return{hash:r,name:"RSA-PSS",saltLength:parseInt(e.slice(-3),10)>>3};case"RS256":case"RS384":case"RS512":return{hash:r,name:"RSASSA-PKCS1-v1_5"};case"ES256":case"ES384":case"ES512":return{hash:r,name:"ECDSA",namedCurve:t.namedCurve};case"Ed25519":case"EdDSA":return{name:"Ed25519"};case"ML-DSA-44":case"ML-DSA-65":case"ML-DSA-87":return{name:e};default:throw new S(`alg ${e} is not supported either by JOSE or your javascript runtime`)}}async function De(e,t,r){if(t instanceof Uint8Array){if(!e.startsWith("HS"))throw new TypeError(ye(t,"CryptoKey","KeyObject","JSON Web Key"));return crypto.subtle.importKey("raw",t,{hash:`SHA-${e.slice(-3)}`,name:"HMAC"},!1,[r])}return he(t,e,r),t}async function Oe(e,t,r,n){const a=await De(e,t,"verify");we(e,a);const i=We(e,a.algorithm);try{return await crypto.subtle.verify(i,a,r,n)}catch{return!1}}async function _e(e,t,r){if(!P(e))throw new f("Flattened JWS must be an object");if(e.protected===void 0&&e.header===void 0)throw new f('Flattened JWS must have either of the "protected" or "header" members');if(e.protected!==void 0&&typeof e.protected!="string")throw new f("JWS Protected Header incorrect type");if(e.payload===void 0)throw new f("JWS Payload missing");if(typeof e.signature!="string")throw new f("JWS Signature missing or incorrect type");if(e.header!==void 0&&!P(e.header))throw new f("JWS Unprotected Header incorrect type");let n={};if(e.protected)try{const se=C(e.protected);n=JSON.parse(T.decode(se))}catch{throw new f("JWS Protected Header is invalid")}if(!me(n,e.header))throw new f("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");const a={...n,...e.header},i=ge(f,new Map([["b64",!0]]),r==null?void 0:r.crit,n,a);let o=!0;if(i.has("b64")&&(o=n.b64,typeof o!="boolean"))throw new f('The "b64" (base64url-encode payload) Header Parameter must be a boolean');const{alg:s}=a;if(typeof s!="string"||!s)throw new f('JWS "alg" (Algorithm) Header Parameter missing or invalid');const d=r&&Ae("algorithms",r.algorithms);if(d&&!d.has(s))throw new Y('"alg" (Algorithm) Header Parameter value not allowed');if(o){if(typeof e.payload!="string")throw new f("JWS Payload must be a string")}else if(typeof e.payload!="string"&&!(e.payload instanceof Uint8Array))throw new f("JWS Payload must be a string or an Uint8Array instance");let w=!1;typeof t=="function"&&(t=await t(n,e),w=!0),Je(s,t,"verify");const b=fe(e.protected!==void 0?D(e.protected):new Uint8Array,D("."),typeof e.payload=="string"?o?D(e.payload):V.encode(e.payload):e.payload);let y;try{y=C(e.signature)}catch{throw new f("Failed to base64url decode the signature")}const R=await Pe(t,s);if(!await Oe(s,R,y,b))throw new Z;let l;if(o)try{l=C(e.payload)}catch{throw new f("Failed to base64url decode the payload")}else typeof e.payload=="string"?l=V.encode(e.payload):l=e.payload;const g={payload:l};return e.protected!==void 0&&(g.protectedHeader=n),e.header!==void 0&&(g.unprotectedHeader=e.header),w?{...g,key:R}:g}async function xe(e,t,r){if(e instanceof Uint8Array&&(e=T.decode(e)),typeof e!="string")throw new f("Compact JWS must be a string or Uint8Array");const{0:n,1:a,2:i,length:o}=e.split(".");if(o!==3)throw new f("Invalid Compact JWS");const s=await _e({payload:a,protected:n,signature:i},t,r),d={payload:s.payload,protectedHeader:s.protectedHeader};return typeof t=="function"?{...d,key:s.key}:d}const He=e=>Math.floor(e.getTime()/1e3),re=60,ne=re*60,B=ne*24,Me=B*7,Le=B*365.25,$e=/^(\+|\-)? ?(\d+|\d+\.\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)(?: (ago|from now))?$/i;function z(e){const t=$e.exec(e);if(!t||t[4]&&t[1])throw new TypeError("Invalid time period format");const r=parseFloat(t[2]),n=t[3].toLowerCase();let a;switch(n){case"sec":case"secs":case"second":case"seconds":case"s":a=Math.round(r);break;case"minute":case"minutes":case"min":case"mins":case"m":a=Math.round(r*re);break;case"hour":case"hours":case"hr":case"hrs":case"h":a=Math.round(r*ne);break;case"day":case"days":case"d":a=Math.round(r*B);break;case"week":case"weeks":case"w":a=Math.round(r*Me);break;default:a=Math.round(r*Le);break}return t[1]==="-"||t[4]==="ago"?-a:a}const G=e=>e.includes("/")?e.toLowerCase():`application/${e.toLowerCase()}`,Ue=(e,t)=>typeof e=="string"?t.includes(e):Array.isArray(e)?t.some(Set.prototype.has.bind(new Set(e))):!1;function Ne(e,t,r={}){let n;try{n=JSON.parse(T.decode(t))}catch{}if(!P(n))throw new U("JWT Claims Set must be a top-level JSON object");const{typ:a}=r;if(a&&(typeof e.typ!="string"||G(e.typ)!==G(a)))throw new p('unexpected "typ" JWT header value',n,"typ","check_failed");const{requiredClaims:i=[],issuer:o,subject:s,audience:d,maxTokenAge:w}=r,b=[...i];w!==void 0&&b.push("iat"),d!==void 0&&b.push("aud"),s!==void 0&&b.push("sub"),o!==void 0&&b.push("iss");for(const l of new Set(b.reverse()))if(!(l in n))throw new p(`missing required "${l}" claim`,n,l,"missing");if(o&&!(Array.isArray(o)?o:[o]).includes(n.iss))throw new p('unexpected "iss" claim value',n,"iss","check_failed");if(s&&n.sub!==s)throw new p('unexpected "sub" claim value',n,"sub","check_failed");if(d&&!Ue(n.aud,typeof d=="string"?[d]:d))throw new p('unexpected "aud" claim value',n,"aud","check_failed");let y;switch(typeof r.clockTolerance){case"string":y=z(r.clockTolerance);break;case"number":y=r.clockTolerance;break;case"undefined":y=0;break;default:throw new TypeError("Invalid clockTolerance option type")}const{currentDate:R}=r,I=He(R||new Date);if((n.iat!==void 0||w)&&typeof n.iat!="number")throw new p('"iat" claim must be a number',n,"iat","invalid");if(n.nbf!==void 0){if(typeof n.nbf!="number")throw new p('"nbf" claim must be a number',n,"nbf","invalid");if(n.nbf>I+y)throw new p('"nbf" claim timestamp check failed',n,"nbf","check_failed")}if(n.exp!==void 0){if(typeof n.exp!="number")throw new p('"exp" claim must be a number',n,"exp","invalid");if(n.exp<=I-y)throw new x('"exp" claim timestamp check failed',n,"exp","check_failed")}if(w){const l=I-n.iat,g=typeof w=="number"?w:z(w);if(l-y>g)throw new x('"iat" claim timestamp check failed (too far in the past)',n,"iat","check_failed");if(l<0-y)throw new p('"iat" claim timestamp check failed (it should be in the past)',n,"iat","check_failed")}return n}async function Be(e,t,r){var o;const n=await xe(e,t,r);if((o=n.protectedHeader.crit)!=null&&o.includes("b64")&&n.protectedHeader.b64===!1)throw new U("JWTs MUST NOT use unencoded payload");const i={payload:Ne(n.protectedHeader,n.payload,r),protectedHeader:n.protectedHeader};return typeof t=="function"?{...i,key:n.key}:i}const W=document.getElementById("jwtInput"),ae=document.getElementById("jwtHeader"),ie=document.getElementById("jwtPayload"),q=document.getElementById("jwtMessage"),M=document.getElementById("jwtMeta"),Ve=document.getElementById("jwtJwksUrl"),_=document.getElementById("jwtVerifyBtn"),L=document.getElementById("jwtVerifyOutput");function h(e,t=!1){q.textContent=e,q.classList.toggle("message--error",t)}function $(e){const t=e.replace(/-/g,"+").replace(/_/g,"/"),r=(4-t.length%4)%4,n=t+"=".repeat(r),a=atob(n);let i="";for(let o=0;o<a.length;o+=1)i+=`%${`00${a.charCodeAt(o).toString(16)}`.slice(-2)}`;return decodeURIComponent(i)}function X(e){return JSON.stringify(e,null,2)}function Fe(e){if(!e){M.textContent="";return}const t=Math.floor(Date.now()/1e3),r=e.exp,n=e.nbf,a=[];if(typeof r=="number"){const i=r<t,o=new Date(r*1e3).toISOString();a.push(i?u("jwt.meta.expired",{date:o}):u("jwt.meta.expires",{date:o}))}if(typeof n=="number"){const i=n<=t,o=new Date(n*1e3).toISOString();a.push(i?u("jwt.meta.nbfActive",{date:o}):u("jwt.meta.nbfPending",{date:o}))}M.textContent=a.join(" · ")}function oe(){try{const e=W.value.trim();if(!e){h(u("jwt.error.empty"),!0);return}const t=e.split(".");if(t.length<2){h(u("jwt.error.format"),!0);return}const r=JSON.parse($(t[0])),n=JSON.parse($(t[1]));ae.textContent=X(r),ie.textContent=X(n),Fe(n),h(u("jwt.success"))}catch{h(u("jwt.error.decode"),!0)}}function ze(e){const t=e.split(".");if(t.length<2)throw new Error(u("jwt.error.format"));return JSON.parse($(t[0]))}async function Ge(){const e=W.value.trim(),t=Ve.value.trim();if(!e){h(u("jwt.error.empty"),!0);return}if(!t){h("JWKS URL을 입력하세요.",!0);return}try{const r=ze(e),i=((await(await fetch(t)).json()).keys||[]).find(d=>!r.kid||d.kid===r.kid);if(!i)throw new Error("JWKS에 매칭되는 키가 없습니다.");const o=await be(i,i.alg||r.alg||"RS256"),s=await Be(e,o,{});L.value=JSON.stringify({verified:!0,alg:r.alg,kid:r.kid||null,payload:s.payload},null,2),h("JWT 서명 검증 성공.")}catch(r){L.value="",h(`JWT 서명 검증 실패: ${r.message}`,!0)}}document.getElementById("decodeJwtBtn").addEventListener("click",oe);document.getElementById("jwtClearBtn").addEventListener("click",()=>{W.value="",ae.textContent="",ie.textContent="",M.textContent="",L.value="",h("")});document.getElementById("jwtSampleBtn").addEventListener("click",()=>{const e="eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkRldlVzZXIiLCJpYXQiOjE1MTYyMzkwMjIsImV4cCI6MjUxNjIzOTAyMn0.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ";W.value=e,oe()});document.querySelectorAll("button[data-copy]").forEach(e=>{e.addEventListener("click",()=>{const t=document.getElementById(e.dataset.copy);if(!t)return;const r=t.value||t.textContent||"";navigator.clipboard.writeText(r).then(()=>h(u("common.copySuccess"))).catch(()=>h(u("common.copyFail"),!0))})});_==null||_.addEventListener("click",()=>{Ge()});
