var k=Object.defineProperty;var j=(e,t,r)=>t in e?k(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r;var c=(e,t,r)=>j(e,typeof t!="symbol"?t+"":t,r);import"./site-3xrs3AWN.js";const L=new TextEncoder,C=new TextDecoder;function ee(...e){const t=e.reduce((a,{length:i})=>a+i,0),r=new Uint8Array(t);let n=0;for(const a of e)r.set(a,n),n+=a.length;return r}function _(e){const t=new Uint8Array(e.length);for(let r=0;r<e.length;r++){const n=e.charCodeAt(r);if(n>127)throw new TypeError("non-ASCII string encountered in encode()");t[r]=n}return t}function te(e){if(Uint8Array.fromBase64)return Uint8Array.fromBase64(e);const t=atob(e),r=new Uint8Array(t.length);for(let n=0;n<t.length;n++)r[n]=t.charCodeAt(n);return r}function K(e){if(Uint8Array.fromBase64)return Uint8Array.fromBase64(typeof e=="string"?e:C.decode(e),{alphabet:"base64url"});let t=e;t instanceof Uint8Array&&(t=C.decode(t)),t=t.replace(/-/g,"+").replace(/_/g,"/");try{return te(t)}catch{throw new TypeError("The input to be decoded is not correctly encoded.")}}class S extends Error{constructor(r,n){var a;super(r,n);c(this,"code","ERR_JOSE_GENERIC");this.name=this.constructor.name,(a=Error.captureStackTrace)==null||a.call(Error,this,this.constructor)}}c(S,"code","ERR_JOSE_GENERIC");class h extends S{constructor(r,n,a="unspecified",i="unspecified"){super(r,{cause:{claim:a,reason:i,payload:n}});c(this,"code","ERR_JWT_CLAIM_VALIDATION_FAILED");c(this,"claim");c(this,"reason");c(this,"payload");this.claim=a,this.reason=i,this.payload=n}}c(h,"code","ERR_JWT_CLAIM_VALIDATION_FAILED");class I extends S{constructor(r,n,a="unspecified",i="unspecified"){super(r,{cause:{claim:a,reason:i,payload:n}});c(this,"code","ERR_JWT_EXPIRED");c(this,"claim");c(this,"reason");c(this,"payload");this.claim=a,this.reason=i,this.payload=n}}c(I,"code","ERR_JWT_EXPIRED");class B extends S{constructor(){super(...arguments);c(this,"code","ERR_JOSE_ALG_NOT_ALLOWED")}}c(B,"code","ERR_JOSE_ALG_NOT_ALLOWED");class y extends S{constructor(){super(...arguments);c(this,"code","ERR_JOSE_NOT_SUPPORTED")}}c(y,"code","ERR_JOSE_NOT_SUPPORTED");class f extends S{constructor(){super(...arguments);c(this,"code","ERR_JWS_INVALID")}}c(f,"code","ERR_JWS_INVALID");class O extends S{constructor(){super(...arguments);c(this,"code","ERR_JWT_INVALID")}}c(O,"code","ERR_JWT_INVALID");class V extends S{constructor(r="signature verification failed",n){super(r,n);c(this,"code","ERR_JWS_SIGNATURE_VERIFICATION_FAILED")}}c(V,"code","ERR_JWS_SIGNATURE_VERIFICATION_FAILED");const p=(e,t="algorithm.name")=>new TypeError(`CryptoKey does not support this operation, its ${t} must be ${e}`),A=(e,t)=>e.name===t;function D(e){return parseInt(e.name.slice(4),10)}function re(e){switch(e){case"ES256":return"P-256";case"ES384":return"P-384";case"ES512":return"P-521";default:throw new Error("unreachable")}}function ne(e,t){if(!e.usages.includes(t))throw new TypeError(`CryptoKey does not support this operation, its usages must include ${t}.`)}function ae(e,t,r){switch(t){case"HS256":case"HS384":case"HS512":{if(!A(e.algorithm,"HMAC"))throw p("HMAC");const n=parseInt(t.slice(2),10);if(D(e.algorithm.hash)!==n)throw p(`SHA-${n}`,"algorithm.hash");break}case"RS256":case"RS384":case"RS512":{if(!A(e.algorithm,"RSASSA-PKCS1-v1_5"))throw p("RSASSA-PKCS1-v1_5");const n=parseInt(t.slice(2),10);if(D(e.algorithm.hash)!==n)throw p(`SHA-${n}`,"algorithm.hash");break}case"PS256":case"PS384":case"PS512":{if(!A(e.algorithm,"RSA-PSS"))throw p("RSA-PSS");const n=parseInt(t.slice(2),10);if(D(e.algorithm.hash)!==n)throw p(`SHA-${n}`,"algorithm.hash");break}case"Ed25519":case"EdDSA":{if(!A(e.algorithm,"Ed25519"))throw p("Ed25519");break}case"ML-DSA-44":case"ML-DSA-65":case"ML-DSA-87":{if(!A(e.algorithm,t))throw p(t);break}case"ES256":case"ES384":case"ES512":{if(!A(e.algorithm,"ECDSA"))throw p("ECDSA");const n=re(t);if(e.algorithm.namedCurve!==n)throw p(n,"algorithm.namedCurve");break}default:throw new TypeError("CryptoKey does not support this operation")}ne(e,r)}function F(e,t,...r){var n;if(r=r.filter(Boolean),r.length>2){const a=r.pop();e+=`one of type ${r.join(", ")}, or ${a}.`}else r.length===2?e+=`one of type ${r[0]} or ${r[1]}.`:e+=`of type ${r[0]}.`;return t==null?e+=` Received ${t}`:typeof t=="function"&&t.name?e+=` Received function ${t.name}`:typeof t=="object"&&t!=null&&(n=t.constructor)!=null&&n.name&&(e+=` Received an instance of ${t.constructor.name}`),e}const ie=(e,...t)=>F("Key must be ",e,...t),G=(e,t,...r)=>F(`Key for the ${e} algorithm must be `,t,...r),q=e=>{if((e==null?void 0:e[Symbol.toStringTag])==="CryptoKey")return!0;try{return e instanceof CryptoKey}catch{return!1}},z=e=>(e==null?void 0:e[Symbol.toStringTag])==="KeyObject",X=e=>q(e)||z(e);function se(...e){const t=e.filter(Boolean);if(t.length===0||t.length===1)return!0;let r;for(const n of t){const a=Object.keys(n);if(!r||r.size===0){r=new Set(a);continue}for(const i of a){if(r.has(i))return!1;r.add(i)}}return!0}const oe=e=>typeof e=="object"&&e!==null;function T(e){if(!oe(e)||Object.prototype.toString.call(e)!=="[object Object]")return!1;if(Object.getPrototypeOf(e)===null)return!0;let t=e;for(;Object.getPrototypeOf(t)!==null;)t=Object.getPrototypeOf(t);return Object.getPrototypeOf(e)===t}function ce(e,t){if(e.startsWith("RS")||e.startsWith("PS")){const{modulusLength:r}=t.algorithm;if(typeof r!="number"||r<2048)throw new TypeError(`${e} requires key modulusLength to be 2048 bits or larger`)}}function de(e){let t,r;switch(e.kty){case"AKP":{switch(e.alg){case"ML-DSA-44":case"ML-DSA-65":case"ML-DSA-87":t={name:e.alg},r=e.priv?["sign"]:["verify"];break;default:throw new y('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break}case"RSA":{switch(e.alg){case"PS256":case"PS384":case"PS512":t={name:"RSA-PSS",hash:`SHA-${e.alg.slice(-3)}`},r=e.d?["sign"]:["verify"];break;case"RS256":case"RS384":case"RS512":t={name:"RSASSA-PKCS1-v1_5",hash:`SHA-${e.alg.slice(-3)}`},r=e.d?["sign"]:["verify"];break;case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":t={name:"RSA-OAEP",hash:`SHA-${parseInt(e.alg.slice(-3),10)||1}`},r=e.d?["decrypt","unwrapKey"]:["encrypt","wrapKey"];break;default:throw new y('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break}case"EC":{switch(e.alg){case"ES256":t={name:"ECDSA",namedCurve:"P-256"},r=e.d?["sign"]:["verify"];break;case"ES384":t={name:"ECDSA",namedCurve:"P-384"},r=e.d?["sign"]:["verify"];break;case"ES512":t={name:"ECDSA",namedCurve:"P-521"},r=e.d?["sign"]:["verify"];break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":t={name:"ECDH",namedCurve:e.crv},r=e.d?["deriveBits"]:[];break;default:throw new y('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break}case"OKP":{switch(e.alg){case"Ed25519":case"EdDSA":t={name:"Ed25519"},r=e.d?["sign"]:["verify"];break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":t={name:e.crv},r=e.d?["deriveBits"]:[];break;default:throw new y('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break}default:throw new y('Invalid or unsupported JWK "kty" (Key Type) Parameter value')}return{algorithm:t,keyUsages:r}}async function W(e){if(!e.alg)throw new TypeError('"alg" argument is required when "jwk.alg" is not present');const{algorithm:t,keyUsages:r}=de(e),n={...e};return n.kty!=="AKP"&&delete n.alg,delete n.use,crypto.subtle.importKey("jwk",n,t,e.ext??!(e.d||e.priv),e.key_ops??r)}async function fe(e,t,r){if(!T(e))throw new TypeError("JWK must be an object");let n;switch(t??(t=e.alg),n??(n=e.ext),e.kty){case"oct":if(typeof e.k!="string"||!e.k)throw new TypeError('missing "k" (Key Value) Parameter value');return K(e.k);case"RSA":if("oth"in e&&e.oth!==void 0)throw new y('RSA JWK "oth" (Other Primes Info) Parameter value is not supported');return W({...e,alg:t,ext:n});case"AKP":{if(typeof e.alg!="string"||!e.alg)throw new TypeError('missing "alg" (Algorithm) Parameter value');if(t!==void 0&&t!==e.alg)throw new TypeError("JWK alg and alg option value mismatch");return W({...e,ext:n})}case"EC":case"OKP":return W({...e,alg:t,ext:n});default:throw new y('Unsupported "kty" (Key Type) Parameter value')}}function ue(e,t,r,n,a){if(a.crit!==void 0&&(n==null?void 0:n.crit)===void 0)throw new e('"crit" (Critical) Header Parameter MUST be integrity protected');if(!n||n.crit===void 0)return new Set;if(!Array.isArray(n.crit)||n.crit.length===0||n.crit.some(s=>typeof s!="string"||s.length===0))throw new e('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');let i;r!==void 0?i=new Map([...Object.entries(r),...t.entries()]):i=t;for(const s of n.crit){if(!i.has(s))throw new y(`Extension Header Parameter "${s}" is not recognized`);if(a[s]===void 0)throw new e(`Extension Header Parameter "${s}" is missing`);if(i.get(s)&&n[s]===void 0)throw new e(`Extension Header Parameter "${s}" MUST be integrity protected`)}return new Set(n.crit)}function he(e,t){if(t!==void 0&&(!Array.isArray(t)||t.some(r=>typeof r!="string")))throw new TypeError(`"${e}" option must be an array of strings`);if(t)return new Set(t)}const x=e=>T(e)&&typeof e.kty=="string",le=e=>e.kty!=="oct"&&(e.kty==="AKP"&&typeof e.priv=="string"||typeof e.d=="string"),pe=e=>e.kty!=="oct"&&e.d===void 0&&e.priv===void 0,ye=e=>e.kty==="oct"&&typeof e.k=="string";let g;const M=async(e,t,r,n=!1)=>{g||(g=new WeakMap);let a=g.get(e);if(a!=null&&a[r])return a[r];const i=await W({...t,alg:r});return n&&Object.freeze(e),a?a[r]=i:g.set(e,{[r]:i}),i},me=(e,t)=>{var s;g||(g=new WeakMap);let r=g.get(e);if(r!=null&&r[t])return r[t];const n=e.type==="public",a=!!n;let i;if(e.asymmetricKeyType==="x25519"){switch(t){case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":break;default:throw new TypeError("given KeyObject instance cannot be used for this algorithm")}i=e.toCryptoKey(e.asymmetricKeyType,a,n?[]:["deriveBits"])}if(e.asymmetricKeyType==="ed25519"){if(t!=="EdDSA"&&t!=="Ed25519")throw new TypeError("given KeyObject instance cannot be used for this algorithm");i=e.toCryptoKey(e.asymmetricKeyType,a,[n?"verify":"sign"])}switch(e.asymmetricKeyType){case"ml-dsa-44":case"ml-dsa-65":case"ml-dsa-87":{if(t!==e.asymmetricKeyType.toUpperCase())throw new TypeError("given KeyObject instance cannot be used for this algorithm");i=e.toCryptoKey(e.asymmetricKeyType,a,[n?"verify":"sign"])}}if(e.asymmetricKeyType==="rsa"){let o;switch(t){case"RSA-OAEP":o="SHA-1";break;case"RS256":case"PS256":case"RSA-OAEP-256":o="SHA-256";break;case"RS384":case"PS384":case"RSA-OAEP-384":o="SHA-384";break;case"RS512":case"PS512":case"RSA-OAEP-512":o="SHA-512";break;default:throw new TypeError("given KeyObject instance cannot be used for this algorithm")}if(t.startsWith("RSA-OAEP"))return e.toCryptoKey({name:"RSA-OAEP",hash:o},a,n?["encrypt"]:["decrypt"]);i=e.toCryptoKey({name:t.startsWith("PS")?"RSA-PSS":"RSASSA-PKCS1-v1_5",hash:o},a,[n?"verify":"sign"])}if(e.asymmetricKeyType==="ec"){const d=new Map([["prime256v1","P-256"],["secp384r1","P-384"],["secp521r1","P-521"]]).get((s=e.asymmetricKeyDetails)==null?void 0:s.namedCurve);if(!d)throw new TypeError("given KeyObject instance cannot be used for this algorithm");t==="ES256"&&d==="P-256"&&(i=e.toCryptoKey({name:"ECDSA",namedCurve:d},a,[n?"verify":"sign"])),t==="ES384"&&d==="P-384"&&(i=e.toCryptoKey({name:"ECDSA",namedCurve:d},a,[n?"verify":"sign"])),t==="ES512"&&d==="P-521"&&(i=e.toCryptoKey({name:"ECDSA",namedCurve:d},a,[n?"verify":"sign"])),t.startsWith("ECDH-ES")&&(i=e.toCryptoKey({name:"ECDH",namedCurve:d},a,n?[]:["deriveBits"]))}if(!i)throw new TypeError("given KeyObject instance cannot be used for this algorithm");return r?r[t]=i:g.set(e,{[t]:i}),i};async function Se(e,t){if(e instanceof Uint8Array||q(e))return e;if(z(e)){if(e.type==="secret")return e.export();if("toCryptoKey"in e&&typeof e.toCryptoKey=="function")try{return me(e,t)}catch(n){if(n instanceof TypeError)throw n}let r=e.export({format:"jwk"});return M(e,r,t)}if(x(e))return e.k?K(e.k):M(e,e,t,!0);throw new Error("unreachable")}const b=e=>e==null?void 0:e[Symbol.toStringTag],H=(e,t,r)=>{var n,a;if(t.use!==void 0){let i;switch(r){case"sign":case"verify":i="sig";break;case"encrypt":case"decrypt":i="enc";break}if(t.use!==i)throw new TypeError(`Invalid key for this operation, its "use" must be "${i}" when present`)}if(t.alg!==void 0&&t.alg!==e)throw new TypeError(`Invalid key for this operation, its "alg" must be "${e}" when present`);if(Array.isArray(t.key_ops)){let i;switch(!0){case r==="verify":case e==="dir":case e.includes("CBC-HS"):i=r;break;case e.startsWith("PBES2"):i="deriveBits";break;case/^A\d{3}(?:GCM)?(?:KW)?$/.test(e):!e.includes("GCM")&&e.endsWith("KW")?i="unwrapKey":i=r;break;case r==="encrypt":i="wrapKey";break;case r==="decrypt":i=e.startsWith("RSA")?"unwrapKey":"deriveBits";break}if(i&&((a=(n=t.key_ops)==null?void 0:n.includes)==null?void 0:a.call(n,i))===!1)throw new TypeError(`Invalid key for this operation, its "key_ops" must include "${i}" when present`)}return!0},we=(e,t,r)=>{if(!(t instanceof Uint8Array)){if(x(t)){if(ye(t)&&H(e,t,r))return;throw new TypeError('JSON Web Key for symmetric algorithms must have JWK "kty" (Key Type) equal to "oct" and the JWK "k" (Key Value) present')}if(!X(t))throw new TypeError(G(e,t,"CryptoKey","KeyObject","JSON Web Key","Uint8Array"));if(t.type!=="secret")throw new TypeError(`${b(t)} instances for symmetric algorithms must be of type "secret"`)}},Ee=(e,t,r)=>{if(x(t))switch(r){case"decrypt":case"sign":if(le(t)&&H(e,t,r))return;throw new TypeError("JSON Web Key for this operation must be a private JWK");case"encrypt":case"verify":if(pe(t)&&H(e,t,r))return;throw new TypeError("JSON Web Key for this operation must be a public JWK")}if(!X(t))throw new TypeError(G(e,t,"CryptoKey","KeyObject","JSON Web Key"));if(t.type==="secret")throw new TypeError(`${b(t)} instances for asymmetric algorithms must not be of type "secret"`);if(t.type==="public")switch(r){case"sign":throw new TypeError(`${b(t)} instances for asymmetric algorithm signing must be of type "private"`);case"decrypt":throw new TypeError(`${b(t)} instances for asymmetric algorithm decryption must be of type "private"`)}if(t.type==="private")switch(r){case"verify":throw new TypeError(`${b(t)} instances for asymmetric algorithm verifying must be of type "public"`);case"encrypt":throw new TypeError(`${b(t)} instances for asymmetric algorithm encryption must be of type "public"`)}};function Ae(e,t,r){switch(e.substring(0,2)){case"A1":case"A2":case"di":case"HS":case"PB":we(e,t,r);break;default:Ee(e,t,r)}}function be(e,t){const r=`SHA-${e.slice(-3)}`;switch(e){case"HS256":case"HS384":case"HS512":return{hash:r,name:"HMAC"};case"PS256":case"PS384":case"PS512":return{hash:r,name:"RSA-PSS",saltLength:parseInt(e.slice(-3),10)>>3};case"RS256":case"RS384":case"RS512":return{hash:r,name:"RSASSA-PKCS1-v1_5"};case"ES256":case"ES384":case"ES512":return{hash:r,name:"ECDSA",namedCurve:t.namedCurve};case"Ed25519":case"EdDSA":return{name:"Ed25519"};case"ML-DSA-44":case"ML-DSA-65":case"ML-DSA-87":return{name:e};default:throw new y(`alg ${e} is not supported either by JOSE or your javascript runtime`)}}async function ge(e,t,r){if(t instanceof Uint8Array){if(!e.startsWith("HS"))throw new TypeError(ie(t,"CryptoKey","KeyObject","JSON Web Key"));return crypto.subtle.importKey("raw",t,{hash:`SHA-${e.slice(-3)}`,name:"HMAC"},!1,[r])}return ae(t,e,r),t}async function ve(e,t,r,n){const a=await ge(e,t,"verify");ce(e,a);const i=be(e,a.algorithm);try{return await crypto.subtle.verify(i,a,r,n)}catch{return!1}}async function Ke(e,t,r){if(!T(e))throw new f("Flattened JWS must be an object");if(e.protected===void 0&&e.header===void 0)throw new f('Flattened JWS must have either of the "protected" or "header" members');if(e.protected!==void 0&&typeof e.protected!="string")throw new f("JWS Protected Header incorrect type");if(e.payload===void 0)throw new f("JWS Payload missing");if(typeof e.signature!="string")throw new f("JWS Signature missing or incorrect type");if(e.header!==void 0&&!T(e.header))throw new f("JWS Unprotected Header incorrect type");let n={};if(e.protected)try{const Z=K(e.protected);n=JSON.parse(C.decode(Z))}catch{throw new f("JWS Protected Header is invalid")}if(!se(n,e.header))throw new f("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");const a={...n,...e.header},i=ue(f,new Map([["b64",!0]]),r==null?void 0:r.crit,n,a);let s=!0;if(i.has("b64")&&(s=n.b64,typeof s!="boolean"))throw new f('The "b64" (base64url-encode payload) Header Parameter must be a boolean');const{alg:o}=a;if(typeof o!="string"||!o)throw new f('JWS "alg" (Algorithm) Header Parameter missing or invalid');const d=r&&he("algorithms",r.algorithms);if(d&&!d.has(o))throw new B('"alg" (Algorithm) Header Parameter value not allowed');if(s){if(typeof e.payload!="string")throw new f("JWS Payload must be a string")}else if(typeof e.payload!="string"&&!(e.payload instanceof Uint8Array))throw new f("JWS Payload must be a string or an Uint8Array instance");let m=!1;typeof t=="function"&&(t=await t(n,e),m=!0),Ae(o,t,"verify");const w=ee(e.protected!==void 0?_(e.protected):new Uint8Array,_("."),typeof e.payload=="string"?s?_(e.payload):L.encode(e.payload):e.payload);let l;try{l=K(e.signature)}catch{throw new f("Failed to base64url decode the signature")}const P=await Se(t,o);if(!await ve(o,P,l,w))throw new V;let u;if(s)try{u=K(e.payload)}catch{throw new f("Failed to base64url decode the payload")}else typeof e.payload=="string"?u=L.encode(e.payload):u=e.payload;const E={payload:u};return e.protected!==void 0&&(E.protectedHeader=n),e.header!==void 0&&(E.unprotectedHeader=e.header),m?{...E,key:P}:E}async function Ce(e,t,r){if(e instanceof Uint8Array&&(e=C.decode(e)),typeof e!="string")throw new f("Compact JWS must be a string or Uint8Array");const{0:n,1:a,2:i,length:s}=e.split(".");if(s!==3)throw new f("Invalid Compact JWS");const o=await Ke({payload:a,protected:n,signature:i},t,r),d={payload:o.payload,protectedHeader:o.protectedHeader};return typeof t=="function"?{...d,key:o.key}:d}const Te=e=>Math.floor(e.getTime()/1e3),Q=60,Y=Q*60,$=Y*24,Pe=$*7,Re=$*365.25,We=/^(\+|\-)? ?(\d+|\d+\.\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)(?: (ago|from now))?$/i;function U(e){const t=We.exec(e);if(!t||t[4]&&t[1])throw new TypeError("Invalid time period format");const r=parseFloat(t[2]),n=t[3].toLowerCase();let a;switch(n){case"sec":case"secs":case"second":case"seconds":case"s":a=Math.round(r);break;case"minute":case"minutes":case"min":case"mins":case"m":a=Math.round(r*Q);break;case"hour":case"hours":case"hr":case"hrs":case"h":a=Math.round(r*Y);break;case"day":case"days":case"d":a=Math.round(r*$);break;case"week":case"weeks":case"w":a=Math.round(r*Pe);break;default:a=Math.round(r*Re);break}return t[1]==="-"||t[4]==="ago"?-a:a}const N=e=>e.includes("/")?e.toLowerCase():`application/${e.toLowerCase()}`,Je=(e,t)=>typeof e=="string"?t.includes(e):Array.isArray(e)?t.some(Set.prototype.has.bind(new Set(e))):!1;function _e(e,t,r={}){let n;try{n=JSON.parse(C.decode(t))}catch{}if(!T(n))throw new O("JWT Claims Set must be a top-level JSON object");const{typ:a}=r;if(a&&(typeof e.typ!="string"||N(e.typ)!==N(a)))throw new h('unexpected "typ" JWT header value',n,"typ","check_failed");const{requiredClaims:i=[],issuer:s,subject:o,audience:d,maxTokenAge:m}=r,w=[...i];m!==void 0&&w.push("iat"),d!==void 0&&w.push("aud"),o!==void 0&&w.push("sub"),s!==void 0&&w.push("iss");for(const u of new Set(w.reverse()))if(!(u in n))throw new h(`missing required "${u}" claim`,n,u,"missing");if(s&&!(Array.isArray(s)?s:[s]).includes(n.iss))throw new h('unexpected "iss" claim value',n,"iss","check_failed");if(o&&n.sub!==o)throw new h('unexpected "sub" claim value',n,"sub","check_failed");if(d&&!Je(n.aud,typeof d=="string"?[d]:d))throw new h('unexpected "aud" claim value',n,"aud","check_failed");let l;switch(typeof r.clockTolerance){case"string":l=U(r.clockTolerance);break;case"number":l=r.clockTolerance;break;case"undefined":l=0;break;default:throw new TypeError("Invalid clockTolerance option type")}const{currentDate:P}=r,R=Te(P||new Date);if((n.iat!==void 0||m)&&typeof n.iat!="number")throw new h('"iat" claim must be a number',n,"iat","invalid");if(n.nbf!==void 0){if(typeof n.nbf!="number")throw new h('"nbf" claim must be a number',n,"nbf","invalid");if(n.nbf>R+l)throw new h('"nbf" claim timestamp check failed',n,"nbf","check_failed")}if(n.exp!==void 0){if(typeof n.exp!="number")throw new h('"exp" claim must be a number',n,"exp","invalid");if(n.exp<=R-l)throw new I('"exp" claim timestamp check failed',n,"exp","check_failed")}if(m){const u=R-n.iat,E=typeof m=="number"?m:U(m);if(u-l>E)throw new I('"iat" claim timestamp check failed (too far in the past)',n,"iat","check_failed");if(u<0-l)throw new h('"iat" claim timestamp check failed (it should be in the past)',n,"iat","check_failed")}return n}async function De(e,t,r){var s;const n=await Ce(e,t,r);if((s=n.protectedHeader.crit)!=null&&s.includes("b64")&&n.protectedHeader.b64===!1)throw new O("JWTs MUST NOT use unencoded payload");const i={payload:_e(n.protectedHeader,n.payload,r),protectedHeader:n.protectedHeader};return typeof t=="function"?{...i,key:n.key}:i}const v={token:document.getElementById("jwkvToken"),jwks:document.getElementById("jwkvJwksUrl"),run:document.getElementById("jwkvVerifyBtn"),output:document.getElementById("jwkvOutput"),message:document.getElementById("jwkvMessage")};function J(e,t=!1){v.message.textContent=e,v.message.classList.toggle("message--error",t)}function Ie(e){const t=e.split(".")[0];return JSON.parse(atob(t.replaceAll("-","+").replaceAll("_","/")))}async function He(){const e=v.token.value.trim(),t=v.jwks.value.trim();if(!e||!t){J("JWT와 JWKS URL을 모두 입력하세요.",!0);return}const r=Ie(e),i=((await(await fetch(t)).json()).keys||[]).find(d=>!r.kid||d.kid===r.kid);if(!i){J("JWKS에서 일치하는 키(kid)를 찾지 못했습니다.",!0);return}const s=await fe(i,i.alg||r.alg||"RS256"),o=await De(e,s,{});v.output.value=JSON.stringify({header:r,payload:o.payload},null,2),J("서명 검증 성공.")}v.run.addEventListener("click",()=>He().catch(e=>J(`검증 실패: ${e.message}`,!0)));
